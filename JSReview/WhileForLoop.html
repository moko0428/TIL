<!DOCTYPE html>
<html>
    <head>
        <meta charset="uft-8">
        <title>과제출력결과</title>
    </head>
    <body>
        <script>
            /*
            //[반복문의 마지막 값]
            //1. 얼럿 창에 마지막으로 뜨는 값은 무엇일까? 이유도 설명
            //답: 1
            //풀이: 반복이 하나씩 끝날 때마다 i는 1씩 줄어든다. while(i)은 i = 0일 때 멈춘다.
            let i = 3;
            while(i){
                alert(i--); //3이 출력되고 i는 2
                alert(i--); //2가 출력되고 i는 1
                alert(i--); //1이 출력되고 i는 0

            }
            */
            /*
            //[while 반복문의 출력값 예상하기]
            //2. while 반복문이 순차적으로 실행될 때마다 얼럿 창에 어떤 값이 출력될지 예상해보자.
            //답: 1~4, 1~5
            //풀이: 전위형 ++i 는 i를 먼저 증가시키고 새로운 값을 반환하기 때문에 첫 번째 while 반복문에선 1과 5를 비교(1<5)하고, 얼럿 창엔 1이 출력된다.
            //      1에 이어서 2,3,4.. 이 출력된다. i앞에 ++가 붙어있기 때문에 5는 항상 증가 이후의 값과 비교된다.
            //      i=4 이후에 i의 값이 5로 증가하면 while(5<5)안의 비교가 실패하기 때문에 반복문은 멈춘다. 따라서 5는 출력되지 않는다.
            //      후위형 i++은 i를 증가시키긴 하지만 기존값을 반환한다. 따라서 첫 번째 while 반복문 에선 0과 5를 비교한다. 이 점이 전위 연산자와의 차이점이다.
            //      그런데 alert문은 조건문과 별개로 1을 출력한다. i는 이미 증가한 이후이기 때문이다.
            //전위형 증가 연산자를 사용한 경우(++i) :
            let i = 0;
            while(++i < 5) alert(i);
            // 후위형 증가 연산자를 사용한 경우(i++) :
            let i = 0;
            while (i++ < 5) alert(i);
            */
           /*
            //['for'반복문의 출력값 예상하기]
            //3. for 반복문이 순차적으로 실행될 때마다 얼럿 창에 어떤 값이 출력될지 예상해보자
            //답: 모든 작업이 시작되기 전 일단 i = 0이다, i < 5 조건을 만족하는지 확인한다, 위 조건이 true이면 반복문의 본문 alert(i)가 실행되고, 그 이후 i++가 실행된다.
            //    증가 연산자가 반환하는 값은 (2) 에서 쓰이지 않기 때문에 i++와 ++i에 차이가 없다.
            //풀이:
            for( let i = 0; i < 5; i++) alert(i);
            for(let j=0; j < 5; ++j) alert(j);
            */

            /*
            //[for 반복문을 이용하여 짝수 출력하기]
            //4. for 반복문을 이용하여 2부터 10까지 숫자 중 짝수만을 출력해보자.
            //답:for (let i = 2; i <= 10; i++){
            //    if(i%2==0) alert(i);
            //}
            //풀이: 나머지 연산자 %를 사용하면 짝수인지를 확인할 수 있다.
            */
            /*    
            //['for' 반복문을 'while' 반복문으로 바꾸기]
            //5. for 반복문을 while 반복문으로 바꾸되, 동작 방식에는 변화가 없도록 해보자. 출력 결과도 동일해야한다.
            //답: let i = 0;
            //    while (i < 3){
            //       alert('number ${i}!');
            //       i++;
            //}
            //풀이:
            for(let i = 0; i < 3; i++){
                alert('number ${i}!');
            }
            */
            //[사용자가 유효한 값을 입력할 때까지 프롬프트 창 띄우기]
            //6. 사용자가 100보다 큰 숫자를 입력하도록 안내하는 프롬프트 창을 띄워보자. 사용자가 조건에 맞지 않은 값을 입력한 경우 반복문을 사용해 동일한 프롬프트 창을 띄워주자.
            //   사용자가 100을 초과하는 숫자를 입력하거나 취소 버튼을 누른 경우, 혹은 아무것도 입력하지 않고 확인 버튼을 누른 경우엔 더는 프롬프트 창을 띄워주지 않아도 된다.
            //   사용자가 오직 숫자만 입력한다고 가정하고 답안을 작성하도록 해보자. 숫자가 아닌 값이 입력되는 예외 상황은 처리하지 않아도 된다.
            //답: let num;
            //    do {
            //      num = prompt("100을 초과하는 숫자를 입력해주제요.", 0);    
            //} while (num <= 100 && num);
            //풀이: do..while 반복문을 사용해 아래 두 조건이 모두 truthy인 경우 프롬프트 창이 뜨게 하면 된다.
            //      1. num <= 100 인지 확인하기, 100보다 작거나 같은 값을 입력한 경우 프롬프트 창이 떠야한다.
            //      2. num이 null이나 빈 문자열인지 확인하기, num이 null이나 빈 문자열이면 && num이 거짓이 되므로 while 반복문이 종료된다.
            //  참고: num이 null인 경우 num <= 100 은 true 가 되므로 두 번째 조건이 없으면 취소 버튼을 눌러도 반복문이 계속해서 실행된다. 따라서 위 두 조건을 모두 확인해야 한다.
            //[소수 출력하기]
            //7. 소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다.
            //   다시 말해 1과 그 수 자신 이외의 자연수로는 나눌 수 없는 자연수를 소수라고 부른다.
            //   5는 2 나 3, 4로 나눌 수 없기 때문에 소수이다. 5를 이들 숫자로 나누면 나머지가 있기 때문이다.
            //   2부터 n 까지의 숫자 중 소수만 출력해주는 코드를 작성해보자.
            //   n = 10 이라면 결과는 2,3,5,7이 되어야 한다.
            //   주의 : 작성한 코드는 임의의 숫자 n에 대해 동작해야 한다.
            //답: let n = 10;
            //    nextPrime:
            //    for(let i = 2; i <= n; i++){
            //      for(let j = 2; j < i; j++){
            //          if(i%j == 0) continue nextPrime;
            //}
            //alert(i);
            //}
            //풀이:제수를 2와 i의 제곱근 사이에서 찾으면 좀 더 나아진다. 아주 큰 n에 대해서 이자체나 수체와 같이 좀 더 어려운 수학과 복잡한 알고리즘을 이용해 소수 검색 알고리즘을 개선할 수 있다.
        </script>
    </body>
</html>