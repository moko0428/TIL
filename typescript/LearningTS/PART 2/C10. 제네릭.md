# 10.0 제네릭

`타입 시스템에서 선언된 변수는 완전히 새롭게 타입된 세계가 된다!`

지금까지의 모든 구문은 해당 구문이 작성될 때 완전히 알려진 타입과 함께 사용해야 했다.

그러나 때로는 코드에서 호출하는 방식에 따라 다양한 타입으로 작동하도록 의도할 수 있다.

- 자바스크립트에서 다음 identity 함수는 모든 가능한 타입으로 input을 받고, 동일한 input을 출력으로 반환한다.

> 🤔 그렇다면 여기서 매개변수 타입과 반환 타입을 어떻게 설명해야 할까?

```js
function identity(input) {
  return input;
}
identity("abc");
identity(123);
identity({ quote: "I think your self emerges more clearly over time." });
```

당연하게도 input을 any로 선언할 수 있지만 그렇게 하면 함수의 반환 타입 역시 any가 된다.

```js
function identity(input: any) {
  return input;
}
let value = identity(42); // value: any 타입
```

- input이 모든 입력을 허용한다면, input 타입과 함수 반환 타입 간의 관계를 말할 수 있는 방법이 필요하다.
- 타입스크립트는 `제네릭(generic)`을 사용해 타입 간의 관계를 알아낸다.
- 타입스크립트에서 함수와 같은 구조체는 `제네릭 타입 매개변수`를 원하는 수만큼 선언할 수 있다.
- 제네릭 타입 매개변수는 제네릭 구조체의 각 사용법에 따라 타입이 결정된다.
- 이러한 타입 매개변수는 구조체의 각 인스턴스에서 서로 다른 일부 타입을 나타내기 위해 구조체의 타입으로 사용된다.
- 타입 매개변수는 구조체의 각 인스턴스에 대해 `타입 인수`라고 하는 서로 다른 타입을 함께 제공할 수 있지만, 타입 인수가 제공된 인스턴스 내에서는 일관성을 유지한다.
- 타입 매개변수는 전형적으로 T나 U 같은 단일 문자 이름 또는 Key와 Value 같은 파스칼 케이스 이름을 갖는다.
- 이번에 다루는 모든 구조체에서는 `<,>`를 사용해 `someFunction<T>` 또는 `SomeInterface<T>` 처럼 제네릭을 선언한다.

# 10.1 제네릭 함수

- 매개변수 괄호 바로 앞 홑화살괄호`(<,>)`로 묶인 타입 매개변수에 별칭을 배치해 함수를 제네릭으로 만든다.
  - 그러면 해당 타입 매개변수를 함수의 본문 내부의 매개변수 타입 애너테이션, 반환 타입 애너테이션, 타입 애너테이션에서 사용할 수 있다.
- 다음 identity 함수는 input 매개변수에 대한 타입 매개변수 T를 선언한다.
  - 이를 통해 타입스크립트는 함수의 반환 타입이 T임을 유추한다.
    - 그러면 타입스크립트는 identity가 호출될 때마다 T에 대한 다른 타입을 유추할 수 있다.

```js
function identity<T>(input: T) {
  return input;
}
const numeric = identity("me"); // 타입 : "me"
const stringy = identity(123); // 타입 : 123
```

- 화살표 함수도 제네릭을 만들 수 있다.
- 화살표 함수의 제네릭 선언은 매개변수 목록 바로 전인 ( 앞에 위치한다.

> 다음 화살표 함수는 앞서 선언했던 것과 기능적으로 동일한 함수 선언식이다.

```js
const identity = <T>(input: T) => input;

identity(123); // 타입 : 123
```

- 이런 방식으로 함수에 타입 매개변수를 추가하면 타입 안정성을 유지하고 any 타입을 피하면서 다른 입력과 함께 재사용할 수 있다.

## 10.1.1 명시적 제네릭 호출 타입

- 제네릭 함수를 호출할 때 대부분의 타입스크립트는 함수가 호출되는 방식에 따라 타입 인수를 유추한다.
- 예를 들어 이전 예제의 identity 함수에서 타입스크립트의 타입 검사기는 identity에 제공된 인수를 사용해 해당 함수 매개변수의 타입 인수를 유추한다.
- 하지만 클래스 멤버와 변수 타입 인수를 해석하기 위해 타입스크립트에 알려줘야 하는 함수 호출 정보가 충분하지 않을 수도 있다.
- 이러한 현상은 타입 인수를 알 수 없는 제네릭 구문이 다른 제네릭 구문에 제공된 경우 주로 발생한다.

#### 예제

- 다음 logWrapper 함수는 매개변수 타입이 logWrapper의 타입 매개변수 Input으로 설정된 callback을 받는다.

- 이처럼 매개변수 타입이 명시적으로 선언된 callback과 logWrapper가 함께 호출되는 경우 타입스크립트는 타입 인수를 유추할 수 있다.

- 그러나 매개변수 타입을 모르는 경우에는 타입스크립트는 Input이 무엇이 되어야 하는지 알아낼 방법이 없다.

## 10.1.2 다중 함수 타입 매개변수

- 임의의 수의 타입 매개변수를 쉼표로 구분해 함수를 정의한다.
- 제네릭 함수의 각 호출은 각 타입 매개면수에 대한 자체 값 집합을 확인할 수 있다.

#### 예제

makeTuple은 두 개의 타입 매개변수를 선언하고 입력된 값을 읽기 전용 튜플로 반환한다.

```js
function makeTuple<First, Second>(first: First, second: Second){
    return [first, second] as const;
}
let tuple = makeTuple(true, "abc"); //value : readonly [boolean, string] 타입
```

- 함수가 여러 개의 매개변수를 선언하면 해당 함수에 대한 호출은 명시적으로 제네릭 타입을 모두 선언하지 않거나 모두 선언해야 한다.
- 타입스크립트는 아직 제네릭 호출 중 일부 타입만을 유추하지는 못한다.

#### 예제

makePair는 두 개의 타입 매개변수를 받으므로 두 개를 모두 명시적으로 지정하거나 지정하지 않아야한다.

```js
function makePair<Key, Value>(key: Key, value: Value) {
  return { key, value };
}
makePair("abc", 123); //{key: string; value: number}

makePair < string, number > ("abc", 123); // {key: string; value: number}
makePair < "abc", 123 > ("abc", 123); // {key:"abc"; value:123}

makePair < string > ("abc", 123);
//Error : Expected 2 type arguments, but got 1.
```

> 💡 제네릭 구조체에서 두 개보다 많은 타입 매개변수를 사용하지 말자. 런타임 함수 매개변수처럼 많이 사용할수록 코드를 읽고 이해하는 것이 점점 어려워진다.

# 10.2 제네릭 인터페이스

- 인터페이스도 제네릭으로 선언할 수 있다.
- 인터페이스는 함수와 유사한 제네릭 규칙을 따르며 인터페이스 이름 뒤 <과> 사이에 선언된 임의의 수의 타입 매개변수를 갖는다.
- 해당 제네릭 타입은 나중에 멤버 타입과 같이 선언의 다른 곳에서 사용할 수 있다.
- 타입스크립트에서 내장 Array 메서드는 제네릭 인터페이스로 정의된다는 점이다.
- Array는 타입 매개변수 T를 사용해서 배열 안에 저장된 데이터의 타입을 나타낸다.

## 10.2.1 유추된 제네릭 인터페이스 타입

- 제네릭 함수와 마찬가지로 제네릭 인터페이스의 타입 인수는 사용법에서 유추할 수 있다.
- 타입스크립트는 제네릭 타입을 취하는 것으로 선언된 위치에 제동된 값의 타입에서 타입 인수를 유추한다.

# 10.3 제네릭 클래스

- 인터페이스처럼 클래스도 나중에 멤버에서 사용할 임의의 수의 타입 매개변수를 선언할 수 있다.
- 클래스의 각 인스턴스는 타입 매개변수로 각자 다른 타입 인수 집합을 가진다.

## 10.3.1 명시적 제네릭 클래스 타입

- 제네릭 클래스 인스턴스와는 제네릭 함수를 호출하는 것과 동일한 타입 인수 유추 규칙을 따른다.
- new Secret(12345, "luggage")와 같이 함수 생성자에 전달된 매개변수의 타입으로부터 타입 인수를 유추할 수 있다면 타입스크립트는 유추된 타입을 사용한다.
- 하지만 생성자에 전달된 인수에서 클래스 타입 인수를 유추할 수 없는 경우에는 타입 인수의 기본값은 unknown이 된다.

## 10.3.2 제네릭 클래스 확장

- 제네릭 클래스는 extends 키워드 다음에 오는 기본 클래스로 사용할 수 있다.
- 타입스크립트는 사용법에서 기본 클래스에 대한 타입 인수를 유추하지 않는다.
- 기본값이 없는 모든 타입 인수는 명시적 타입 애너테이션을 사용해 지정해야한다.

## 10.3.3 제네릭 인터페이스 구현

- 제네릭 클래스는 모든 필요한 매개변수를 제공함으로써 제네릭 인터페이스를 구현한다.
- 제네릭 인터페이스는 제네릭 기본 클래스를 확장하는 것과 유사하게 작동한다.
- 기본 인터페이스의 모든 타입 매개변수는 클래스에 선언되어야 한다.

## 10.3.4 메서드 제네릭

- 클래스 메서드는 클래스 인스턴스와 별개로 자체 제네릭 타입을 선언할 수 있다.
- 제네릭 클래스 메서드에 대한 각각의 호출은 각 타입 매개변수에 대해 다른 타입 인수를 갖는다.

## 10.3.5 정적 클래스 제네릭

- 클래스의 정적(static) 멤버는 인스턴스 멤버와 구별되고 클래스의 특정 인스턴스와 연결되어 있지 않다.
- 클래스의 정적 멤버는 자체 타입 매개변수를 선언할 수 있지만 클래스에 선언된 어떤 타입 매개변수에도 접근할 수 없다.

# 10.4 제네릭 타입 별칭

- 타입 인수를 사용해 제네릭을 만드는 타입스크립트의 마지막 구조체는 타입 별칭이다.
- 각 타입 별칭에는 T를 받는 Nullish 타입과 같은 임의의 수의 타입 매개변수가 주어진다.
  `type Nullish<T> = T | null | undefined;`

## 10.4.1 제네릭 판별된 유니언

- 4장 '객체'에서 언급한 판별된 유니언은 일반화된 우아한 자바스크립트 패턴과 타입스크립트의 타입 내로잉을 아름답게 결합하므로 타입스크립트에서 가장 좋은 기능이다.
- 판별된 유니언 사용법 중 가장 좋은 용도는 데이터의 성공적인 결과 또는 오류로 인한 실패를 나타낸느 제네릭 '결과' 타입을 만들기 위해 타입 인수를 추가하는 것이다.

# 10.5 제네릭 제한자

- 타입스크립트는 제네릭 타입 매개변수의 동작을 수행하는 구문도 제공한다.

## 10.5.1 제네릭 기본값

- 지금까지 제네릭 타입이 타입 애너테이션에 사용되거나 extends 또는 implements의 기본 클래스로 사용되는 경우 각 타입 매개변수에 대한 타입 인수를 제공해야 한다고 이야기하였다.
- 타입 매개변수 선언 뒤에 =와 기본 타입을 배치해 타입 인수를 명시적으로 제공할 수 있다.
- 기본값은 타입 인수가 명시적으로 선언되지 않고 유추할 수 없는 모든 후속 타입에서 사용된다.

# 10.6 제한된 제네릭 타입

- 기본적으로 제네릭 타입에는 클래스, 인터페이스, 원시값, 유니언, 별칭 등 모든 타입을 제공할 수 있다.
- 그러나 일부 함수는 제한된 타입에서만 작동해야 한다.
- 타입스크립트는 타입 매개변수가 타입을 확장해야 한다고 선언할 수 있으며 별칭 타입에만 허용되는 작업이다. 타입 매개변수를 제한하는 구문은 매개변수 이름 뒤에 extends 키워드를 배치하고 그 뒤에 이를 제한할 타입을 배치한다.

## 10.6.1 keyof와 제한된 타입 매개변수

- 9장 '타입 제한자'에서 소개한 keyof 연산자는 제한된 타입 매개변수와도 잘 작동한다.
- extends와 keyof를 함께 사요하면 타입 매개변수를 이전 타입 매개변수의 키로 제한할 수 있다.
- 또한 제네릭 타입의 키를 지정하는 유일한 방법이기도 하다.

# 10.7 Promise

- 제네릭이 어떻게 작동하는지 살펴보았으니 드디어 최신 자바스크립트의 핵심 기능인 Promise를 이야기할 시간이다.
- 간단히 말하자면 자바스크립트의 Promise는 네트워크 요청과 같이 요청 이후 결과를 받기까지 대기가 필요한 것을 나타낸다.
- 각 Promise는 대기 중인 작업이 'resolve(성공적으로 완료됨)' 또는 'reject(오류 발생)'하는 경우 콜백을 등록하기 위한 메서드를 제공한다.

## 10.7.1 Promise 생성

- 타입스크립트에서 Promise 생성자는 단일 매개변수를 받도록 작성된다.
- 해당 매개변수의 타입은 제네릭 Promise 클래스에 선언된 타입 매개변수에 의존한다.

## 10.7.2 async 함수

- 자바스크립트에서 async 키워드를 사용해 선언한 모든 함수는 Promise를 반환한다.
- 자바스크립트에서 async 함수에 따라서 반환된 값이 Thenable(.then() 메서드가 있는 객체, 실제로는 거의 항상 Promise)이 아닌 경우, Promise.resolve가 호출된 것처럼 Promise로 래핑(wrapping)된다.

# 10.8 제네릭 올바르게 사용하기

- 이 장에서 살펴본 Promise<Value> 구현처럼 제네릭은 코드에서 타입을 설명하는 데 많은 유연성을 제공할 수 있지만, 코드가 빠르게 복잡해질 수 있다.
- 타입스크립트를 처음 접한 개발자는 이따금 제네릭을 과도하게 사용해 읽기 혼란스럽고 지나치게 복잡한 코드를 만들기도 한다.
- 타입스크립트의 모범 사례는 필요할 때만 제네릭을 사용하고, 제네릭을 사용할 때는 무엇을 위해 사용하는지 명확히 해야한다.

## 10.8.1 제네릭 황금률

- 함수에 타입 매개변수가 필요한지 여부를 판단할 수 있는 간단하고 빠른 방법은 타입 매개변수가 최소 두 번 이상 사용되었는지 확인하는 것이다.
- 제네릭은 타입 같의 관계를 설명하므로 제네릭 타입 매개변수가 한 곳에만 나타나면 여러 타입 간의 관계를 정의할 수 없다.
- 따라서 각 함수 타입 매개변수는 매개변수에 사용되어야 하고, 그 다음 적어도 하나의 다른 매개변수 또는 함수의 반환 타입에서도 사용되어야 한다.

## 10.8.2 제네릭 명명 규칙

- 타입스크립트를 포함한 많은 언어가 지키는 타입 매개변수에 대한 표준 명명 규칙(naming convention)은 기본적으로 첫 번째 타입 인수로 T를 사용하고, 후속 타입 매개변수가 존재하면 U, V 등을 사용하는 것이다.
- 타입 인수가 어떻게 사용되어야 하는지 맥락과 관련된 정보가 알려진 경우 명명 규칙은 경우에 따라 용어의 첫 글자를 사용하는 것으로 확장된다.
