# 8. 클래스

- 자바스크립트는 비주류였다.
- 타입스크립트의 타입 검사기 외에도 트랜스파일러(transpiler)가 강조되고 그 예시로 클래스가 자주 등장했다.

# 8.1 클래스 메서드

- 타입스크립트는 독립 함수(standalone function)를 이해하는 것과 동일한 방식으로 메서드를 이해한다.
- 매개변수 타입에 기본값을 별도로 지정하지 않으면 any 타입을 갖는다.
- 메서드를 호출하려면 허용 가능한 인수가 필요하고, 재귀 함수가 아니라면 대부분 반환 타입을 유추할 수 있다.

### 예제

- 다음은 string 타입의 단일 필수 매개변수를 갖는 greet 클래스 메서드를 가진 Greeter 클래스를 정의하는 코드이다.

```js
class Greeter{
    greet(name:string){
        console.log(`${name}, do your stuff!`);
    }

    new Greeter().greet("Miss Frizzle");

    new Greeter().greet();
    //Error: Expected 1 arguments, but got 0.
}
```

- 클래스 생성자(constructor)는 매개변수와 관련하여 전형적인 클래스 메서드처럼 취급된다.
- 타입스크립트는 메서드 호출 시 올바른 타입의 인수가 올바른 수로 제공되는지 확인하기 위해 타입 검사를 수행한다.

### 예제

- 다음 Greeted 생성자는 message: string으로 매개변수가 제공되어야한다.

```js
class Greeted {
  constructor(message: string) {
    console.log(`As I always say: ${message}!`);
  }
}

new Greeted("take chances, make mistakes, get messy");

new Greeted();
// Error : Expected 1 arguments, but got 0.
```

# 8.2 클래스 속성

- 타입스크립트에서 클래스의 속성을 읽거나 쓰려면 클래스에 명시적으로 선언해야 한다.
- 클래스 속성은 인터페이스와 동일한 구문을 사용해 선언한다.
- 클래스 속성 이름 뒤에는 선택적으로 타입 애너테이션이 붙는다.

<br>

- 타입스크립트는 생성자 내의 할당에 대해서 그 멤버가 클래스에 존재하는 멤버인지 추론하려고 시도하지 않는다.

### 예제

- 다음 예제에서 destination은 string으로 명시적으로 선언되어 있어 FieldTrip 클래스 인스턴스에 할당되고 접근할 수 있다.
- 클래스 nonexistent 속성을 선언하지 않았기 때문에 생성자에서 this.nonexistent 할당은 허용되지 않는다.

```js
class FieldTrip {
  destination: string;

  constructor(destination: string) {
    this.destination = destination;
    console.log(`We're going to ${this.destination}!`);

    this.nonexistent = destination;
    // Error : Property 'nonexistent' does exist on type 'FieldTrip'.
  }
}
```

- 클래스 속성을 명시적으로 선언하면 타입스크립트는 클래스 인스턴스에서 무엇이 허용되고, 허용되지 않는지 빠르게 이해할 수 있다.
- 나중에 클래스 인스턴스가 사용될 때, 코드가 trip.nonexistent와 같은 클래스 인스턴스에 존재하지 않는 멤버에 접근하려고 시도하면 타입스크립트 타입 오류를 발생시킨다.

```js
const trip = new FieldTrip("planetarium");

trip.destination;

trip.nonexistent;
//Error: Property 'nonexistent' does not exist on type 'FieldTrip'.
```

## 8.2.1 함수 속성

- 자바스크립트에는 클래스의 멤버를 호출 가능한 함수로 선언하는 두 가지 구문이 있다.

1. myFunction(){}과 같이 멤버 이름 뒤에 괄호를 붙이는 메서드 접근 방식을 앞서 살펴보았다.

- 메서드 접근 방식은 함수를 클래스 프로토타입에 할당하므로 모든 클래스 인스턴스는 동일한 함수 정의를 사용한다.

2. 값이 함수인 속성을 선언하는 방식도 있다.

- 클래스의 인스턴스당 새로운 함수가 생성되며, 항상 클래스 인스턴스를 가리켜야하는 화살표 함수에서 this 스코프를 사용하면 클래스 인스턴스당 새로운 함수를 생성하는 시간과 메모리 비용 측면에서 유용할 수 있다.

- 함수 속성에는 클래스 메서드와 독립 함수의 동일한 구문을 사용해 매개변수와 반환 타입을 지정할 수 있다. 결국엔 함수 속성은 클래스 멤버로 할당된 값이고, 그 값은 함수이다.

## 8.2.2 초기화 검사

- 엄격한 컴파일러 설정이 활성화된 상태에서 타입스크립트는 undefined 타입으로 선언된 각 속성이 생성자에서 할당되었는지 확인한다.
- 엄격한 초기화 검사는 클래스 속성에 값을 할당하지 않는 실수를 예방할 수 있어 유용하다.
- 엄격한 초기화 검사가 없다면, 비록 타입 시스템이 undefined 값에 접근할 수 없다고 말할지라도 클래스 인스턴스는 undefined 값에 접근할 수 있다.

### 확실하게 할당된 속성

- 엄격한 초기화 검사가 유용한 경우가 대부분이지만 클래스 생성자 다음에 클래스 속성을 의도적으로 할당하지 않는 경우가 있을 수도 있다.
- 엄격한 초기화 검사를 적용하면 안 되는 속성인 경우에는 이름 뒤에 !를 추가해 검사를 비활성화하도록 설정한다. 이렇게 하면 타입스크립트 속성이 처음 사용되기 전에 undefined 값이 할당된다.

> 😡 클래스 속성에 대해 엄격한 초기화 검사를 비활성화하는 것은 종종 타입 검사에는 적합하지 않은 방식으로 코드가 설정된다는 신호이다. ! 어서션을 추가하고 속성에 대한 타입 안정성을 줄이는 대신 클래스를 리팩토링해서 어서션이 더 이상 필요하지 않도록하자.

## 8.2.3 선택적 속성

- 인터페이스와 마찬가지로 클래스는 선언된 속성 이름 뒤에 ?를 추가해 속성을 옵션으로 선언한다.
- 선택적 속성은 | undefined를 포함하는 유니언 타입과 거의 동일하게 작동한다.
- 엄격한 초기화 검사는 생성자에서 선택적 속성을 명시적으로 설정하지 않아도 문제가 되지 않는다.

## 8.2.4 읽기 전용 속성

- 인터페이스와 마찬가지로 클래스도 선언된 속성 이름 앞에 readonly 키워드를 추가해 속성을 읽기 전용으로 선언한다.
- readonly 키워드는 타입 시스템에만 존재하며 자바스크립트로 컴파일할 때 삭제된다.
- readonly로 선언된 속성은 선언된 위치 또는 생성자에서 초깃값만 할당할 수 있다.
- 클래스 내의 메서드를 포함한 다른 모든 위치에서 속성은 읽을 수만 있고, 쓸 수는 없다.

> 😡 npm 패키지로 게시한 코드를 사용하는 외부인이 readonly 제한자를 존중하지 않을 수 있다. 특히 자바스크립트를 작성 중이고 타입 검사를 하지 않는 사용자라면 더욱 그러하다. 진정한 읽기 전용 보호가 필요하다면 # private 필드나 get() 함수 속성 사용을 고려해보자.

- 원시 타입의 초깃값을 갖는 readonly로 선언된 속성은 다른 속성과 조금 다르다.
- 이런 속성은 더 넓은 원싯값이 아니라 값의 타입이 가능한 한 좁혀진 리터럴 타입으로 유추된다.
- 타입스크립트는 값이 나중에 변경되지 않는다는 것을 알기 때문에 더 공격적인 초기 타입 내로잉을 편하게 느낀다.
- const 변수가 let 변수보다 더 좁은 타입을 갖는 것과 유사하다.

# 8.3 타입으로서의 클래스

- 타입시스템에서의 클래스는 클래스 선언이 런타임 값(클래스 자체)과 타입 애너테이션에서 사용할 수 있는 타입을 모두 생성한다는 점에서 상대적으로 독특하다.
- 타입스크립트는 클래스의 동일한 멤버를 모두 포함하는 모든 객체 타입을 클래스에 할당할 수 있는 것으로 간주한다.
- 타입스크립트의 구조적 타이핑이 선언되는 방식이 아니라 객체의 형태만 고려하기 때문이다.

> 😁대부분의 실제 코드에서 개발자는 클래스 타입을 요청하는 위치에 객체의 값을 전달하지 않는다. 이러한 구조적인 확인 동작은 예상하지 못한 것처럼 보일 수 있지만 자주 나타나지는 않는다.

# 8.4 클래스와 인터페이스

- 타입스크립트 개발자가 코드에서 객체의 형태를 예측할 수 있도록 인터페이스로 설정하는 방법을 살펴보았다.
- 타입스크립트는 클래스 이름 뒤에 implements 키워드와 인터페이스 이름을 추가함으로써 클래스의 해당 인스턴스가 인터페이스를 준수한다고 선언할 수 있다.
- 클래스를 각 인터페이스에 할당할 수 있어야 함을 타입스크립트에 나타낸다.
- 타입 검사기에 의해 모든 불일치에 대해서 타입 오류가 발생한다.

> 🤔 클래스에 의해 구현되는 인터페이스는 Leaner 인터페이스에서 사용된 것처럼 인터페이스 멤버를 함수로 선언하기 위해 메서드 구문을 사용한다.

- 인터페이스를 구현하는 것으로 클래스를 만들어도 클래스가 사용되는 방식은 변경되지 않는다.
- 클래스가 이미 인터페이스와 일치하는 경우 타입스크립트의 타입 검사기는 인터페이스의 인스턴스가 필요한 곳에서 해당 인스턴스를 사용할 수 있도록 허용한다.
- 타입스크립트는 인터페이스에서 클래스의 메서드 또는 속성 타입을 유추하지 않는다.
- 인터페이스를 구현하는 것은 순전히 안정성 검사를 위해서이다.
- 모든 인터페이스 멤버를 클래스 정의로 복사하지 않는다.
- 대신 인터페이스를 구현하면 클래스 인스턴스가 사용되는 곳에서 나중에 타입 검사기로 신호를 보내고 클래스 정의해서 표면적인 타입 오류가 발생한다.
- 변수에 초깃값이 있더라도 타입 애너테이션을 추가하는 것과 용도가 비슷하다.

## 8.4.1 다중 인터페이스 구현

- 타입스크립트의 클래스는 다중 인터페이스를 구현해 선언할 수 있다.
- 클래스에 구현된 인터페이스 목록은 인터페이스 이름 사이에 쉼표를 넣고, 개수 제한 없이 인터페이스를 사용할 수 있다.
- 실제로 클래스가 한 번에 두 인터페이스를 구현할 수 없도록 정의하는 인터페이스가 있을 수 있다.
- 두 개의 충돌하는 인터페이스를 구현하는 클래스를 선언하려고 하면 클래스에 하나 이상의 타입 오류가 발생한다.
- 두 인터페이스가 매우 다른 객체 형태를 표현하는 경우에는 동일한 클래스로 구현하지 않아야한다.

## 8.5 클래스 확장

- 타입스크립트는 다른 클래스를 확장하거나 하위 클래스를 만드는 자바스크립트 개념에 타입 검사를 추가한다.
- 먼저 기본 클래스에 선언된 모든 메서드나 속성은 파생 클래스라고도 하는 하위 클래스에서 사용할 수 있다.

## 8.5.1 할당 가능성 확장

- 파생 인터페이스가 기본 인터페이스를 확장하는 것과 마찬가지로 하위 클래스도 기본 클래스의 멤버를 상속한다.
- 하위 클래스의 인스턴스는 기본 클래스의 모든 멤버를 가지므로 기본 클래스의 인스턴스가 필요한 모든 곳에서 사용할 수 있다.
- 만약 기본 클래스에 하위 클래스가 가지고 있는 모든 멤버가 없으면 더 구체적인 하위 클래스가 필요할 때 사용할 수 없다.
- 타입스크립트의 구조적 타입에 따라 하위 클래스의 모든 멤버가 동일한 타입의 기본 클래스에 이미 존재하는 경우 기본 클래스의 하위 클래스 대신 사용할 수 있다.

## 8.5.2 재정의된 생성자

- 바닐라 자바스크립트와 마찬가지로 타입스크립트에서 하위 클래스는 자체 생성자를 정의할 필요가 없다.
- 자체 생성자가 없는 하위 클래스는 암묵적으로 기본 클래스의 생성자를 사용한다.
- 자바스크립트에서 하위 클래스가 자체 생성자를 선언하면 super 키워드를 통해 기본 클래스 생성자를 호출해야 한다.
- 하위 클래스 생성자는 기본 클래스에서의 필요 여부와 상관없이 모든 매개변수를 선언할 수 있다.
- 타입스크립트의 타입 검사지는 기본 클래스 생성자를 호출할 때 올바른 매개변수를 사용하는지 확인한다.
- 자바스크립트 규칙에 따르면 하위 클래스의 생성자는 this 또는 super에 접근하기 전에 반드시 기본 클래스에 생성자를 호출해야 한다.
- 타입스크립트는 super()를 호출하기 전에 this 또는 super에 접근하려고 하는 경우 타입 오류를 보고한다.

## 8.5.3 재정의된 메서드

- 하위 클래스의 메서드가 기본 클래스의 메서드에 할당할 수 있는 한 하위 클래스는 기본 클래스와 동일한 이름으로 새 메서드를 다시 선언할 수 있다.
- 기본 클래스를 사용하는 모든 곳에 하위 클래스를 사용할 수 있으므로 새 메서드의 타입도 기본 메서드 대신 사용할 수 있어야 한다는 점을 명심하자.

## 8.5.4 재정의된 속성

- 하위 클래스는 새 타입을 기본 클래스의 타입에 할당할 수 있는 한 동일한 이름으로 기본 클래스의 속성을 명시적으로 다시 선언할 수 있다.
- 재정의된 메서드와 마찬가지로 하위 클래스는 기본 클래스와 구조적으로 일치해야한다.
- 속성을 다시 선언하는 대부분의 하위 클래스는 해당 속성을 유니언 타입의 더 구체적인 하위 집합으로 만들거나 기본 클래스 속성 타입에서 확장되는 타입으로 만든다.
- 속성의 유니언 타입의 허용된 값 집합을 확장할 수는 없다.
- 만약 확장한다면 하위 클래스 속성은 더 이상 기본 클래스 속성 타입에 할당할 수 없다.

# 8.6 추상 클래스

- 때로는 일부 메서드의 구현을 선언하지 않고, 대신 하위 클래스가 해당 메서드를 제공할 것을 예상하고 기본 클래스를 만드는 방법이 유용할 수 있다.
- 추상화하려는 클래스 이름과 메서드 앞에 타입스크립트의 abstract 키워드를 추가한다.
- 이러한 추상화 메서드 선언은 추상화 기본 클래스에서 메서드의 본문을 제공하는 것을 건너뛰고, 대신 인터페이스와 동일한 방식으로 선언된다.
- 구현이 존재한다고 가정할 수 있는 일부 메서드에 대한 정의가 없기 때문에 추상 클래스를 직접 인스턴스화할 수 없다.
- 추상 클래스가 아닌 클래스만 인스턴스화할 수 있다.
- 추상 클래스는 클래스의 세부 사항이 채워질 거라 예상되는 프레임워크에서 자주 사용된다.
- 클래스는 값이 클래스를 준수해야 함을 나타내는 타입 애너테이션으로 사용할 수 있다. 그러나 새 인스턴스를 생성하려면 하위 클래스를 사용해야 한다.

# 8.7 멤버 접근성

- 자바스크립트에서는 클래스 멤버 이름 앞에 #을 추가해 private 클래스 멤버임을 나타낸다.
- private 클래스 멤버는 해당 클래스 인스턴스에서만 접근할 수 있다.
- 자바스크립트 런타임은 클래스 외부 코드 영역에서 private 메서드나 속성에 접근하려고 하면 오류를 발생시킴으로써 프라이버시(privacy)를 강화한다.
- 타입스크립트의 클래스 지원은 자바스크립트의 # 프라이버시보다 먼저 만들어졌다.
  또한 타입스크립트는 private 클래스 멤버를 지원하지만, 타입 시스템에만 존재하는 클래스 메서드와 속성에 대해 좀 더 미묘한 프라이버시 정의 집합을 허용한다.
- 타입스크립트의 멤버 접근성(가시성visibility)은 클래스 멤버의 선언 이름 앞에 다음 키워드 중 하나를 추가해 만든다.

> - public(기본값) : 모든 곳에서 누구나 접근 가능
> - protected : 클래스 내부 또는 하위 클래스에서만 접근 가능
> - private : 클래스 내부에서만 접근 가능

- 이러한 키워드는 순수하게 타입 시스템 내에 존재한다.
- 코드가 자바스크립트로 컴파일 되면 다른 모든 타입 시스템 구문과 함께 키워드로 제거된다.
- 타입스크립트의 멤버 접근성은 타입 시스템에서만 존재하는 반면 자바스크립트의 private 선언은 런타임에도 존재한다는 점이 주요 차이점이다.
- protected 또는 private으로 선언된 타입스크립트 클래스 맴버는 명시적으로 또는 암묵적으로 public으로 선언된 것처럼 동일한 자바스크립트 코드로 컴파일된다.
- 인터페이스와 타입 애너테이션처럼 접근성 키워드는 자바스크립트로 컴파일될 때 제거된다.
- 자바스크립트 런타임에서는 # private 필드만 진정한 private이다.
- 접근성 제한자는 readonly와 함께 표시할 수 있다.
- readonly와 명시적 접근성 키워드로 멤버를 선언하려면 접근성 키워드를 먼저 적어야한다.
- private 필드는 기본적으로 private이므로 private 키워드를 추가할 필요가 없다.

## 8.7.1 정적 필드 제한자

- 자바스크립트는 static 키워드를 사용해 클래스 자체에서 멤버를 선언한다.
- 타입스크립트는 static 키워드를 단독으로 사용하거나 readonly와 접근성 키워드를 함께 사용할 수 있도록 지원한다.
- 함께 사용할 경우 접근성 키워드를 먼저 작성하고, 다음에 static, readonly 키워드가 온다.
- static 클래스 필드에 대해 readonly와 접근성 제한자를 사용하면 해당 필드가 해당 클래스 외부에서 접근되거나 수정되는 것을 제한하는 데 유용한다.
