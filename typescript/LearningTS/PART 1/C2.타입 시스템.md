# 2.1 타입의 종류

'타입'은 자바스크립트에서 다루는 값의 `형태`에 대한 설명이다. 여기서 '형태'란 값에 존재하는 속성과 메서드 그리고 내장되어 있는 typeof 연산자가 설명하는 것을 의미한다.

예를 들어 다음과 같이 초깃값이 `"Aretha"`인 변수를 생성하는 경우, 타입스크립트는 singer 변수가 문자열 타입임을 유추할 수 있다.

```js
let singer = "Aretha";
```

타입스크립트의 가장 기본적인 타입은 자바스크립트의 일곱가지 기본 `원시 타입(primitive type)`과 동일하다.

- null
- undefined
- boolean - true, false
- string - "", '' ...
- number - 0, 0.1, -1 ...
- bigint - 0n, 2n, -2n ...
- symbol - Symbol() ...

변수의 원시 타입을 잊어버렸다면 타입스크립트 플레이그라운드 혹은 IDE에서 원싯값을 갖는 let 변수를 입력하고 변수 이름 위에 마우스를 hover하면 된다.

또한 타입스크립트는 계산된 초깃값을 갖는 변수의 타입을 유추할 수 있을 만큼 충분히 똑똑하다.

## 2.1.1 타입 시스템

`타입 시스템(type system)`은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다.

타입시스템 작동

1. 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인한다.
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다.

타입스크립트의 오류를 표시하는 순서

1. 코드를 읽고 변수 이름을 이해한다.
2. 초깃값이 어떤 타입인지를 보고 결론짓는다.
3. 변수의 .length 멤버를 함수처럼 호출하는 코드를 확인한다.
4. string의 .length 멤버는 함수가 아닌 숫자라는 오류를 표시한다. 즉 함수처럼 호출할 수 없다는 것을 말해준다.

## 2.1.2 오류 종류

타입스크립트를 작성하는 동안 가장 자주 접하게 되는 오류 두 가지는 다음과 같다.

- 구문 오류 : 타입스크립트가 자바스크립트로 변환되는 것을 차단한 경우
- 타입 오류 : 타입 검사기에 따라 일치하지 않는 것이 감지된 경우

### 구문 오류

구문 오류는 타입스크립트가 코드를 이해할 수 없는 잘못된 구문을 감지할 때 발생한다.
이는 타입스크립트가 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단한다.
물론 타입스크립트 코드를 자바스크립트로 변환하는데 사용하는 도구와 설정에 따라 자바스크립트 코드를 얻을 수도 있다.
하지만 결과가 예상과 상당히 다를 수 있다.

다음 타입스크립트에서는 예기치 않은 let에 대한 구문 오류가 발생한다.

```js
let let wat;
//Error : ',' expected
```

### 타입 오류

타입 오류는 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생한다. 오류가 발생했다고 해서 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지는 않는다.
하지만 코드가 실행되면 무언가 충돌하거나 예기치 않게 작동할 수 있음을 나타낸다.

자바스크립트 코드가 원하는 대로 실행되지 않을 가능성이 있다는 신호를 타입 오류로 알려준다. 자바스크립트를 실행하기 전에 타입 오류를 확인하고 발견된 문제를 먼저 해결하는 것이 가장 좋다.

# 2.2 할당 가능성

타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다. 나중에 해당 변수에 새로운 값이 할당되면, 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인한다.

타입스크립트 변수에 동일한 타입의 다른 값이 할당될 때는 문제가 없다. 예로 변수가 처음에 string 값이면 나중에는 다른 string 값을 할당하는 것은 문제가 되지 않는다.

하지만 타입스크립트 변수에 다른 타입의 값이 할당되면 타입 오류가 발생한다.
예로 처음엔 string 값으로 변수를 선언한 다음 나중에 boolean 값을 넣을 수 없다.

타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 `할당 가능성(assignability)`라고 한다. 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인한다.

## 2.2.1 할당 가능성 오류 이해하기

'Type ... is not assignable to type ... ' 형태의 오류는 타입스크립트 코드를 작성할 때 만나게 되는 가장 일반적인 오류 중 하나이다.

해당 오류 메시지에서 언급된 첫 번째 type은 코드에서 변수에 할당하려고 시도하는 값이다.
두 번째 type은 첫 번째 타입. 즉, 값이 할당되는 변수이다.
예로 이전 코드 스니펫에서 `lastName = true`를 작성할 때 boolean 타입인 true 값을 string 타입인 변수 lastName에 할당하려고 했다.

# 2.3 타입 애너테이션

때로는 변수에 타입스크립트가 읽어야 할 초깃값이 없는 경우도 있다.
타입스크립트는 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않는다.
그리고 기본적으로 변수를 암묵적인 any 타입으로 간주한다.
즉, 변수는 세상의 모든 것이 될 수 있음을 나타낸다.

초기 타입을 유추할 수 없는 변수는 `진화하는 any`라고 부른다. 특정 타입을 강제하는 대신 새로운 값이 할당될 때마다 변수 타입에 대한 이해를 발전시킨다.

다음 코드를 보면 진화하는 any 변수인 rocker에 처음에는 문자열이 할당되는데, 이는 toUpperCase() 같은 string 메서드를 갖는 것을 의미하지만, 그 다음에는 number 타입으로 진화되는 것을 확인할 수 있다.

```js
let rocker; //any

rocker = "Lee Jun"; //string

rocker.toUpperCase(); //Ok

rocker = 19.58; //number
rocker.toPrecision(1); //Ok

rocker.toUpperCase();
//Error : 'toUpperCase()' does not exist on type 'number'
```

타입스크립트는 number 타입으로 진화한 변수가 toUpperCase() 메서드를 호출하는 것을 포착했다. 그러나 변수가 string 타입에서 number 타입으로 진화한 것이 처음부터 의도된 것인지에 대한 여부는 더 일찍 알 수 없다.

일반적으로 any 타입을 사용해 any 타입으로 진화하는 것을 허용하게 되면 타입스크립트의 타입 검사 목적을 부분적으로 쓸모없게 만든다.
타입스크립트는 값이 어떤 타입인지 알고 있을 때 가장 잘 작동한다.

any 타입을 가진 값에는 타입스크립트의 값이 어떤 타입인지 기능을 잘 적용할 수 없다. 검사를 위해 알려진 타입이 없기 때문이다.

타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 `타입 애너테이션(type annotation)`을 제공한다. 타입 애너테이션은 변수 이름 뒤에 배치되며 콜론(:)과 타입 이름을 차례대로 기재한다. 그 다음 타입 애너테이션은 rocker 변수가 string 타입임을 나타낸다.

이러한 타입 애너테이션은 타입스크립트에만 존재하며 런타임 코드에 영향을 주지도 않고, 유효한 자바스크립트 구문도 아니다. tsc 명령어를 실행해 타입스크립트 소스 코드를 자바스크립트로 컴파일하면 해당 코드가 삭제된다. 예로 이 예제는 다음 자바스크립트 코드로 컴파일 된다.

```js
let rocker;
rocker = "lee jun";
```

변수에 타입 애너테이션으로 정의한 타입 외의 값을 할당하면 타입 오류가 발생한다.

다음 코드는 string 타입으로 선언된 rocker 변수에 숫자를 할당해 타입 오류가 발생한 상황이다.

```js
let rocker: string;
rocker = 2.25;

//Error : Type 'number' is not assignable to type 'string'.
```

## 2.3.1 불필요한 타입 애너테이션

타입 애너테이션은 타입스크립트가 자체적으로 수집할 수 없는 정보를 타입스크립트에 제공할 수 있다.
타입을 즉시 유추할 수 있는 변수에도 타입 애너테이션을 사용할 수 있다.
하지만 타입스크립트가 아직 알지 못하는 것은 알려주지 못한다.

다음 코드에서 string 타입 애너테이션은 중복이다.
타입스크립트가 이미 firstName이 string 타입임을 유추할 수 있기 때문이다.

```js
let firstName: string = "Jun"; // 타입 시스템은 변경되지 않음
```

초깃값이 있는 변수에 타입 애너테이션을 추가하면 타입스크립트는 변수에 할당된 값의 타입이 일치하는지 확인한다.

다음 firstName은 string 타입으로 선언되었지만, number 값인 25로 초기화되었다.
이렇게 되면 타입스크립트가 호환되지 않는다는 것을 보여준다.

```js
let firstName: string = 25;

//Error : Type 'number' is not assignable to type 'string'.
```

많은 개발자들은 아무것도 변하지 않는 변수에는 타입 애너테이션을 추가하지 않기를 선호한다. 타입 애너테이션을 수동으로 작성하는 일은 번거롭다. 특히 타입이 변경되거나 복잡한 타입일 때 더욱 그렇다.

코드를 명확하게 문서화하거나 실수로 변수 타입이 변경되지 않도록 타입스크립트를 보호하기 위해 변수에 명시적으로 타입 애너테이션을 포함하는 것이 경우에 따라서는 유용할 수 있다.

# 2.4 타입 형태

타입스크립트는 변수에 할당된 값이 원래 타입과 일치하는지 확인하는 것 이상을 수행한다.
타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있다. 만약 코드에서 변수의 속성에 접근하려고 한다면 타입스크립트는 접근하려는 속성이 해당 변수의 타입에 존재하는지 확인한다.

string 타입의 rapper 변수를 선언한다고 가정하자. 나중에 rapper 변수를 사용할 때 타입스크립트가 string 타입에서 사용 가능한 작업만을 허용한다.

```js
let rapper = "Queen Jun";
rapper.length; // Ok
```

타입스크립트가 string 타입에서 작동하는지 알 수 없는 작업은 허용되지 않는다.

```js
rapper.push("!");

//Error : Property 'push' does not exist on type 'string'.
```

타입은 더 복잡한 형태, 특히 객체일수도 있다.
다음 스니펫에선 타입스크립트는 cher 객체에 middleName 키가 없다는 것을 알고 오류를 표시한다.

```js
let cher = {
  firstName: "Lee",
  lastName: "Jun",
};
cher.middleName;
//Error : Property 'middleName' does not exist on type
//'{firstName: string, lastName:string;}',
```

타입스크립트는 객체의 형태에 대한 이해를 바탕으로 할당 가능성 뿐만 아니라 객체 사용과 관련된 문제도 알려준다.

## 2.4.1 모듈

자바스크립트는 비교적 최근까지 서로 다른 파일에 작성된 코드를 공유하는 방법과 관련된 사양을 제공하지 않았다.
ECMAScript 2015에는 파일 간에 `가져오고(import)` `내보내는(export)` 구문을 표준화하기 위해 `ECMA Script 모듈(ECMAScript Modules)(ESM)`이 추가되었다.

참고로 다음 모듈 파일은 `./values` 파일에서 value를 가져오고, 변수 doubled를 내보낸다.

```js
import { value } from "./values";

export const doubled = value * 2;
```

ECMAScript 사양과 일치시키기 위해 이러한 명명법을 사용한다.

- 모듈 : export 또는 import가 있는 파일
- 스크립트 : 모듈이 아닌 모든 파일

타입스크립트는 최신 모듈 파일을 기존 파일과 함께 실행할 수 있다.
모듈 파일에 선언된 모든 것은 해당 파일에서 명시한 export 문에서 내보내지 않는 한 모듈 파일에서만 사용할 수 있다.

한 모듈에서 다른 파일에 선언된 변수와 동일한 이름으로 선언된 변수는 다른 파일의 변수를 가져오지 않는 한 이름 충돌로 간주하지 않는다.

다음은 a.ts와 b.ts 파일 모두 모듈이고 이름이 동일한 shared 변수를 문제없이 내보내는 코드이다. c.ts는 가져온 shared 변수와 c.ts에 정의된 shared 변수의 이름이 충돌되어 타입 오류가 발생한다.

```js
//a.ts
export const shared = "Lee";

//b.ts
export const shared = "Lee";

//c.ts
import { shared } from "./a";
//Error : Import declaration conflicts with local declaration of 'shared'.

export const shared = "Lee";
//Error : Individual declarations in merged declaration
// 'shared' must be all exported or all local.
```

그러나 파일이 스크립트면 타입스크립트는 해당 파일을 전역 `스코프(scope)`로 간주하므로 모든 스크립트가 파일의 내용에 접근할 수 있다. 즉, 스크립트 파일에 선언된 변수는 다른 스크립트 파일에 선언된 변수와 동일한 이름을 가질 수 없다.

다음 a.ts와 b.ts 파일은 모듈 스타일의 export 또는 import 문이 없기 때문에 일반 스크립트로 간주된다. 따라서 동일한 이름의 변수가 동일한 파일에 선언된 것처럼 서로 충돌한다.

```js
//a.ts
const shared = "Lee";
//Error : Cannot redeclare block-scoped variable 'shared'.

//b.ts
const shared = "Lee";
//Error : Cannot redeclare block-scoped variable 'shared'.
```

타입스크립트 파일에 Cannot redeclare... 라는 오류가 표시되면 파일에 아직 export 또는 import 문을 추가하지 않았기 때문일 수 있다.

ECMAScript 사양에 따라 export 또는 import 문 없이 파일을 모듈로 만들어야 한다면 파일의 아무 곳에나 export{}; 를 추가해 강제로 모듈이 되도록 만든다.

```js
//a.ts and b.ts
const shared = "Lee";
export {};
```

# 2.5 요약

타입스크립트의 타입 시스템이 어떻게 작동하는지 살펴보았다.

- '타입'은 무엇인지 알아보고 타입스크립트가 인식하는 원시 타입 이해하기
- '타입 시스템'은 무엇인지 알아보고 타입스크립트의 타입 시스템이 코드를 이해하는 방법 살펴보기
- 타입 오류와 구문 오류의 차이점
- 유추된 변수 타입과 변수 할당 가능성
- 타입 애너테이션으로 변수 타입을 명시적으로 선언하고 any 타입의 진화 방지하기
- 타입 형태에서 객체 멤버 확인하기
- 스크립트 파일과는 다른 ECMAScript 모듈 파일의 선언 스코프
